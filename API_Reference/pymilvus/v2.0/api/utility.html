
<h1>Utility<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 69%" >
<col style="width: 31%" >
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.loading_progress">loading_progress(collection_name, [partition_names,using])</a></p></td>
<td><p>Query the progress of loading.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#pymilvus.utility.wait_for_loading_complete">wait_for_loading_complete(collection_name, [partition_names, timeout, using])</a></p></td>
<td><p>Wait until loading is complete.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.index_building_progress">index_building_progress(collection_name, [using])</a></p></td>
<td><p>Query the progress of index building.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#pymilvus.utility.wait_for_index_building_complete">wait_for_index_building_complete(collection_name, [timeout, using])</a></p></td>
<td><p>Wait util index building is complete.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.has_collection">has_collection(collection_name, [using])</a></p></td>
<td><p>Check if a specified collection exists.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#pymilvus.utility.has_partition">has_partition(collection_name, partition_name, [using])</a></p></td>
<td><p>Check if a specified partition exists.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.list_collections">list_collections([timeout, using])</a></p></td>
<td><p>List all collections.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#pymilvus.utility.drop_collection">drop_collections(collection_name, [timeout, using])</a></p></td>
<td><p>Drop a collection by name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.calc_distance">calc_distance(vectors_left, vectors_right, params, [timeout, using])</a></p></td>
<td><p>Calculate distance between two vector arrays.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#pymilvus.utility.get_query_segment_info">get_query_segment_info([timeout, using])</a></p></td>
<td><p>Get segments information from query nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.load_balance">load_balance(src_node_id, dst_node_id, sealed_segment_ids, [timeout, using])</a></p></td>
<td><p>Do load balancing between query nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#pymilvus.utility.mkts_from_hybridts">mkts_from_hybridts(ts, [milliseconds, delta])</a></p></td>
<td><p>Generate hybrid timestamp with a known one.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.mkts_from_unixtime">mkts_from_unixtime(timestamp, [milliseconds, delta])</a></p></td>
<td><p>Generate hybrid timestamp with Unix time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#pymilvus.utility.mkts_from_datetime">mkts_from_datetime(d_time, [milliseconds, delta])</a></p></td>
<td><p>Generate hybrid timestamp with datatime.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.hybridts_to_unixtime">hybridts_to_unixtime(hybridts)</a></p></td>
<td><p>Convert hybrid timestamp to UNIX Epoch time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#pymilvus.utility.hybridts_to_datetime">hybridts_to_datetime(hybridts, [tz])</a></p></td>
<td><p>Convert hybrid timestamp to datetime.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.create_alias">create_alias(collection_name, alias, [timeout, using])</a></p></td>
<td><p>Specify alias for a collection.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="#pymilvus.utility.alter_alias">alter_alias(collection_name, alias, [timeout, using])</a></p></td>
<td><p>Change the alias of a collection to another collection.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="#pymilvus.utility.drop_alias">drop_alias(alias, [timeout, using])</a></p></td>
<td><p>Delete the alias.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-pymilvus.utility">
<span id="apis-references"></span><h2>APIs References<a class="headerlink" href="#module-pymilvus.utility" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pymilvus.utility.loading_progress">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">loading_progress</code><span class="sig-paren">(</span><em class="sig-param">collection_name</em>, <em class="sig-param">partition_names=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.loading_progress" title="Permalink to this definition">¶</a></dt>
<dd><p>Show #loaded entities vs #total entities.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection_name</strong> (<em>str</em>) -- The name of collection is loading</p></li>
<li><p><strong>partition_names</strong> (<em>str list</em>) -- The names of partitions is loading</p></li>
</ul>
</dd>
<dt class="field-even">Return dict</dt>
<dd class="field-even"><p>Loading progress is a dict contains num of loaded entities and num of total entities.
{'num_loaded_entities':loaded_segments_nums, 'num_total_entities': total_segments_nums}</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>PartitionNotExistException</strong> -- If partition doesn't exist.</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> _DIM = 128
>>> field_int64 = FieldSchema("int64", DataType.INT64, description="int64", is_primary=True)
>>> field_float_vector = FieldSchema("float_vector", DataType.FLOAT_VECTOR, description="float_vector", is_primary=False, dim=_DIM)
>>> schema = CollectionSchema(fields=[field_int64, field_vector], description="get collection entities num")
>>> collection = Collection(name="test_collection", schema=schema)
>>> import pandas as pd
>>> int64_series = pd.Series(data=list(range(10, 20)), index=list(range(10)))i
>>> float_vector_series = [[random.random() for _ in range _DIM] for _ in range (10)]
>>> data = pd.DataFrame({"int64" : int64_series, "float_vector": float_vector_series})
>>> collection.insert(data)
>>> collection.load() # load collection to memory
>>> utility.loading_progress("test_collection")
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.wait_for_loading_complete">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">wait_for_loading_complete</code><span class="sig-paren">(</span><em class="sig-param">collection_name</em>, <em class="sig-param">partition_names=None</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.wait_for_loading_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until loading is done or Raise Exception after timeout.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection_name</strong> (<em>str</em>) -- The name of collection to wait for loading complete</p></li>
<li><p><strong>partition_names</strong> (<em>str list</em>) -- The names of partitions to wait for loading complete</p></li>
<li><p><strong>timeout</strong> (<em>int</em>) -- The timeout for this method, unit: second</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>CollectionNotExistException</strong> -- If collection doesn't exist.</p></li>
<li><p><strong>PartitionNotExistException</strong> -- If partition doesn't exist.</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> _DIM = 128
>>> field_int64 = FieldSchema("int64", DataType.INT64, description="int64", is_primary=True)
>>> field_float_vector = FieldSchema("float_vector", DataType.FLOAT_VECTOR, description="float_vector", is_primary=False, dim=_DIM)
>>> schema = CollectionSchema(fields=[field_int64, field_float_vector], description="get collection entities num")
>>> collection = Collection(name="test_collection", schema=schema)
>>> import pandas as pd
>>> int64_series = pd.Series(data=list(range(10, 20)), index=list(range(10)))i
>>> float_vector_series = [[random.random() for _ in range _DIM] for _ in range (10)]
>>> data = pd.DataFrame({"int64" : int64_series, "float_vector": float_vector_series})
>>> collection.insert(data)
>>> collection.load() # load collection to memory
>>> utility.wait_for_loading_complete("test_collection")
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.index_building_progress">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">index_building_progress</code><span class="sig-paren">(</span><em class="sig-param">collection_name</em>, <em class="sig-param">index_name=''</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.index_building_progress" title="Permalink to this definition">¶</a></dt>
<dd><p>Show # indexed entities vs. # total entities.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection_name</strong> (<em>str</em>) -- The name of collection is building index</p></li>
<li><p><strong>index_name</strong> (<em>str</em>) -- The name of index is building.
Default index_name is to be used if index_name is not specific.</p></li>
</ul>
</dd>
<dt class="field-even">Return dict</dt>
<dd class="field-even"><p>Index building progress is a dict contains num of indexed entities and num of total
entities.
{'total_rows':total_rows,'indexed_rows':indexed_rows}</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>CollectionNotExistException</strong> -- If collection doesn't exist.</p></li>
<li><p><strong>IndexNotExistException</strong> -- If index doesn't exist.</p></li>
</ul>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> _DIM = 128
>>> field_int64 = FieldSchema("int64", DataType.INT64, description="int64", is_primary=True)
>>> field_float_vector = FieldSchema("float_vector", DataType.FLOAT_VECTOR, description="float_vector", is_primary=False, dim=_DIM)
>>> schema = CollectionSchema(fields=[field_int64, field_float_vector], description="test")
>>> collection = Collection(name="test_collection", schema=schema)
>>> import random
>>> import numpy as np
>>> import pandas as pd
>>> vectors = [[random.random() for _ in range(_DIM)] for _ in range(5000)]
>>> int64_series = pd.Series(data=list(range(5000, 10000)), index=list(range(5000)))
>>> vectors = [[random.random() for _ in range(_DIM)] for _ in range (5000)]
>>> data = pd.DataFrame({"int64" : int64_series, "float_vector": vectors})
>>> collection.insert(data)
>>> collection.load() # load collection to memory
>>> index_param = {
>>>    "metric_type": "L2",
>>>    "index_type": "IVF_FLAT",
>>>    "params": {"nlist": 1024}
>>> }
>>> collection.create_index("float_vector", index_param)
>>> utility.index_building_progress("test_collection", "")
>>> utility.loading_progress("test_collection")
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.wait_for_index_building_complete">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">wait_for_index_building_complete</code><span class="sig-paren">(</span><em class="sig-param">collection_name</em>, <em class="sig-param">index_name=''</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.wait_for_index_building_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until building is done or Raise Exception after timeout.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection_name</strong> (<em>str</em>) -- The name of collection to wait</p></li>
<li><p><strong>index_name</strong> (<em>str</em>) -- The name of index to wait</p></li>
<li><p><strong>timeout</strong> (<em>int</em>) -- The timeout for this method, unit: second</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>CollectionNotExistException</strong> -- If collection doesn't exist.</p></li>
<li><p><strong>IndexNotExistException</strong> -- If index doesn't exist.</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> _DIM = 128
>>> field_int64 = FieldSchema("int64", DataType.INT64, description="int64", is_primary=True)
>>> field_float_vector = FieldSchema("float_vector", DataType.FLOAT_VECTOR, description="float_vector", is_primary=False, dim=_DIM)
>>> schema = CollectionSchema(fields=[field_int64, field_float_vector], description="test")
>>> collection = Collection(name="test_collection", schema=schema)
>>> import random
>>> import numpy as np
>>> import pandas as pd
>>> vectors = [[random.random() for _ in range(_DIM)] for _ in range(5000)]
>>> int64_series = pd.Series(data=list(range(5000, 10000)), index=list(range(5000)))
>>> vectors = [[random.random() for _ in range(_DIM)] for _ in range (5000)]
>>> data = pd.DataFrame({"int64" : int64_series, "float_vector": vectors})
>>> collection.insert(data)
>>> collection.load() # load collection to memory
>>> index_param = {
>>>    "metric_type": "L2",
>>>    "index_type": "IVF_FLAT",
>>>    "params": {"nlist": 1024}
>>> }
>>> collection.create_index("float_vector", index_param)
>>> utility.index_building_progress("test_collection", "")
>>> utility.loading_progress("test_collection")
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.has_collection">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">has_collection</code><span class="sig-paren">(</span><em class="sig-param">collection_name</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.has_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a specified collection exists.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>collection_name</strong> (<em>str</em>) -- The name of collection to check.</p>
</dd>
<dt class="field-even">Return bool</dt>
<dd class="field-even"><p>Whether the collection exists.</p>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> _DIM = 128
>>> field_int64 = FieldSchema("int64", DataType.INT64, description="int64", is_primary=True)
>>> field_float_vector = FieldSchema("float_vector", DataType.FLOAT_VECTOR, description="float_vector", is_primary=False, dim=_DIM)
>>> schema = CollectionSchema(fields=[field_int64, field_float_vector], description="test")
>>> collection = Collection(name="test_collection", schema=schema)
>>> utility.has_collection("test_collection")
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.has_partition">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">has_partition</code><span class="sig-paren">(</span><em class="sig-param">collection_name</em>, <em class="sig-param">partition_name</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.has_partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a specified partition exists in a collection.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection_name</strong> (<em>str</em>) -- The collection name of partition to check</p></li>
<li><p><strong>partition_name</strong> (<em>str</em>) -- The name of partition to check.</p></li>
</ul>
</dd>
<dt class="field-even">Return bool</dt>
<dd class="field-even"><p>Whether the partition exist.</p>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> _DIM = 128
>>> field_int64 = FieldSchema("int64", DataType.INT64, description="int64", is_primary=True)
>>> field_float_vector = FieldSchema("float_vector", DataType.FLOAT_VECTOR, description="float_vector", is_primary=False, dim=_DIM)
>>> schema = CollectionSchema(fields=[field_int64, field_float_vector], description="test")
>>> collection = Collection(name="test_collection", schema=schema)
>>> utility.has_partition("_default")
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.list_collections">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">list_collections</code><span class="sig-paren">(</span><em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span> &#x2192; list<a class="headerlink" href="#pymilvus.utility.list_collections" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all collection names.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeout</strong> (<em>float</em>) -- An optional duration of time in seconds to allow for the RPC. When timeout
is set to None, client waits until server response or error occur.</p>
</dd>
<dt class="field-even">Return list[str]</dt>
<dd class="field-even"><p>List of collection names, return when operation is successful</p>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> _DIM = 128
>>> field_int64 = FieldSchema("int64", DataType.INT64, description="int64", is_primary=True)
>>> field_float_vector = FieldSchema("float_vector", DataType.FLOAT_VECTOR, description="float_vector", is_primary=False, dim=_DIM)
>>> schema = CollectionSchema(fields=[field_int64, field_float_vector], description="test")
>>> collection = Collection(name="test_collection", schema=schema)
>>> utility.list_collections()
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.drop_collection">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">drop_collection</code><span class="sig-paren">(</span><em class="sig-param">collection_name</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.drop_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop a collection by name</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection_name</strong> (<em>str</em>) -- A string representing the collection to be deleted</p></li>
<li><p><strong>timeout</strong> (<em>float</em>) -- An optional duration of time in seconds to allow for the RPC. When timeout
is set to None, client waits until server response or error occur.</p></li>
</ul>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> schema = CollectionSchema(fields=[
...     FieldSchema("int64", DataType.INT64, description="int64", is_primary=True),
...     FieldSchema("float_vector", DataType.FLOAT_VECTOR, is_primary=False, dim=128),
... ])
>>> collection = Collection(name="drop_collection_test", schema=schema)
>>> utility.has_collection("drop_collection_test")
>>> True
>>> utility.drop_collection("drop_collection_test")
>>> utility.has_collection("drop_collection_test")
>>> False
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.calc_distance">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">calc_distance</code><span class="sig-paren">(</span><em class="sig-param">vectors_left</em>, <em class="sig-param">vectors_right</em>, <em class="sig-param">params=None</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.calc_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate distance between two vector arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vectors_left</strong> (<em>dict</em>) -- The vectors on the left of operator.</p>
</dd>
</dl>
<p><cite>{&quot;ids&quot;: [1, 2, 3, .... n], &quot;collection&quot;: &quot;c_1&quot;, &quot;partition&quot;: &quot;p_1&quot;, &quot;field&quot;: &quot;v_1&quot;}</cite>
or
<cite>{&quot;float_vectors&quot;: [[1.0, 2.0], [3.0, 4.0], ... [9.0, 10.0]]}</cite>
or
<cite>{&quot;bin_vectors&quot;: [b'', b'N', ... b'Ê']}</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vectors_right</strong> (<em>dict</em>) -- The vectors on the right of operator.</p>
</dd>
</dl>
<p><cite>{&quot;ids&quot;: [1, 2, 3, .... n], &quot;collection&quot;: &quot;col_1&quot;, &quot;partition&quot;: &quot;p_1&quot;, &quot;field&quot;: &quot;v_1&quot;}</cite>
or
<cite>{&quot;float_vectors&quot;: [[1.0, 2.0], [3.0, 4.0], ... [9.0, 10.0]]}</cite>
or
<cite>{&quot;bin_vectors&quot;: [b'', b'N', ... b'Ê']}</cite></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> -- <dl>
<dt>key-value pair parameters</dt><dd><p>Key: &quot;metric_type&quot;/&quot;metric&quot;    Value: &quot;L2&quot;/&quot;IP&quot;/&quot;HAMMING&quot;/&quot;TANIMOTO&quot;, default is &quot;L2&quot;,
Key: &quot;sqrt&quot;    Value: true or false, default is false    Only for &quot;L2&quot; distance
Key: &quot;dim&quot;     Value: set this value if dimension is not a multiple of 8,</p>
<blockquote>
<div><p>otherwise the dimension will be calculted by list length,
only for &quot;HAMMING&quot; and &quot;TANIMOTO&quot;</p>
</div></blockquote>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">type  params</dt>
<dd class="field-odd"><p>dict
Examples of supported metric_type:</p>
<blockquote>
<div><p><cite>{&quot;metric_type&quot;: &quot;L2&quot;, &quot;sqrt&quot;: true}</cite>
<cite>{&quot;metric_type&quot;: &quot;IP&quot;}</cite>
<cite>{&quot;metric_type&quot;: &quot;HAMMING&quot;, &quot;dim&quot;: 17}</cite>
<cite>{&quot;metric_type&quot;: &quot;TANIMOTO&quot;}</cite></p>
</div></blockquote>
<p>Note: metric type are case insensitive</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2-d array distances</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p></p><p>list[list[int]] for &quot;HAMMING&quot; or list[list[float]] for others
Assume the vectors_left: L_1, L_2, L_3
Assume the vectors_right: R_a, R_b
Distance between L_n and R_m we called &quot;D_n_m&quot;
The returned distances are arranged like this:</p>
<blockquote>
<div><dl class="simple">
<dt>[[D_1_a, D_1_b],</dt><dd><p>[D_2_a, D_2_b],
[D_3_a, D_3_b]]</p>
</dd>
</dl>
</div></blockquote>
<p>Note: if some vectors doesn't exist in collection, the returned distance is &quot;-1.0&quot;</p>

</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> vectors_l = [[random.random() for _ in range(64)] for _ in range(5)]
>>> vectors_r = [[random.random() for _ in range(64)] for _ in range(10)]
>>> op_l = {"float_vectors": vectors_l}
>>> op_r = {"float_vectors": vectors_r}
>>> params = {"metric": "L2", "sqrt": True}
>>> results = utility.calc_distance(vectors_left=op_l, vectors_right=op_r, params=params)
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.get_query_segment_info">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">get_query_segment_info</code><span class="sig-paren">(</span><em class="sig-param">collection_name</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.get_query_segment_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Notifies Proxy to return segments information from query nodes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection_name</strong> -- A string representing the collection to get segments info.</p></li>
<li><p><strong>timeout</strong> (<em>float</em>) -- An optional duration of time in seconds to allow for the RPC. When timeout
is set to None, client waits until server response or error occur.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>QuerySegmentInfo:
QuerySegmentInfo is the growing segments's information in query cluster.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>QuerySegmentInfo</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> _DIM = 128
>>> field_int64 = FieldSchema("int64", DataType.INT64, description="int64", is_primary=True)
>>> field_float_vector = FieldSchema("float_vector", DataType.FLOAT_VECTOR, description="float_vector", is_primary=False, dim=_DIM)
>>> schema = CollectionSchema(fields=[field_int64, field_float_vector], description="get collection entities num")
>>> collection = Collection(name="test_get_segment_info", schema=schema)
>>> import pandas as pd
>>> int64_series = pd.Series(data=list(range(10, 20)), index=list(range(10)))i
>>> float_vector_series = [[random.random() for _ in range _DIM] for _ in range (10)]
>>> data = pd.DataFrame({"int64" : int64_series, "float_vector": float_vector_series})
>>> collection.insert(data)
>>> collection.load() # load collection to memory
>>> res = utility.get_query_segment_info("test_get_segment_info")
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.load_balance">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">load_balance</code><span class="sig-paren">(</span><em class="sig-param">src_node_id</em>, <em class="sig-param">dst_node_ids=None</em>, <em class="sig-param">sealed_segment_ids=None</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.load_balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Do load balancing operation from source query node to destination query node.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>src_node_id</strong> (<em>int</em>) -- The source query node id to balance.</p></li>
<li><p><strong>dst_node_ids</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) -- The destination query node ids to balance.</p></li>
<li><p><strong>sealed_segment_ids</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) -- Sealed segment ids to balance.</p></li>
<li><p><strong>timeout</strong> (<em>int</em>) -- The timeout for this method, unit: second</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>BaseException</strong> -- If query nodes not exist.</p></li>
<li><p><strong>BaseException</strong> -- If sealed segments not exist.</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import connections, utility
>>>
>>> connections.connect()
>>>
>>> src_node_id = 0
>>> dst_node_ids = [1]
>>> sealed_segment_ids = []
>>> res = utility.load_balance(src_node_id, dst_node_ids, sealed_segment_ids)
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.mkts_from_hybridts">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">mkts_from_hybridts</code><span class="sig-paren">(</span><em class="sig-param">hybridts</em>, <em class="sig-param">milliseconds=0.0</em>, <em class="sig-param">delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.mkts_from_hybridts" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a hybrid timestamp based on an existing hybrid timestamp, timedelta and incremental time internval.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hybridts</strong> (<em>int</em>) -- The original hybrid timestamp used to generate a new hybrid timestamp. Non-negative interger range from 0 to 18446744073709551615.</p></li>
<li><p><strong>milliseconds</strong> (<em>float</em>) -- Incremental time interval. The unit of time is milliseconds.</p></li>
<li><p><strong>delta</strong> (<em>datetime.timedelta</em>) -- A duration expressing the difference between two date, time, or datetime instances
to microsecond resolution.</p></li>
</ul>
</dd>
<dt class="field-even">Return int</dt>
<dd class="field-even"><p>Hybrid timetamp is a non-negative interger range from 0 to 18446744073709551615.</p>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import Collection, FieldSchema, CollectionSchema, DataType, connections, utility
>>> connections.connect(alias="default")
>>> _DIM = 128
>>> field_int64 = FieldSchema("int64", DataType.INT64, description="int64", is_primary=True)
>>> field_float_vector = FieldSchema("float_vector", DataType.FLOAT_VECTOR, description="float_vector", is_primary=False, dim=_DIM)
>>> schema = CollectionSchema(fields=[field_int64, field_vector], description="get collection entities num")
>>> collection = Collection(name="test_collection", schema=schema)
>>> import pandas as pd
>>> int64_series = pd.Series(data=list(range(10, 20)), index=list(range(10)))i
>>> float_vector_series = [[random.random() for _ in range _DIM] for _ in range (10)]
>>> data = pd.DataFrame({"int64" : int64_series, "float_vector": float_vector_series})
>>> m = collection.insert(data)
>>> ts_new = utility.mkts_from_hybridts(m.timestamp, milliseconds=1000.0)
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.mkts_from_unixtime">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">mkts_from_unixtime</code><span class="sig-paren">(</span><em class="sig-param">epoch</em>, <em class="sig-param">milliseconds=0.0</em>, <em class="sig-param">delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.mkts_from_unixtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a hybrid timestamp based on Unix Epoch time, timedelta and incremental time internval.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>epoch</strong> (<em>float</em>) -- The known Unix Epoch time used to generate a hybrid timestamp.  The Unix Epoch time is the number of seconds
that have elapsed since January 1, 1970 (midnight UTC/GMT).</p></li>
<li><p><strong>milliseconds</strong> (<em>float</em>) -- Incremental time interval. The unit of time is milliseconds.</p></li>
<li><p><strong>delta</strong> (<em>datetime.timedelta</em>) -- A duration expressing the difference between two date, time, or datetime instances
to microsecond resolution.</p></li>
</ul>
</dd>
<dt class="field-even">Return int</dt>
<dd class="field-even"><p>Hybrid timetamp is a non-negative interger range from 0 to 18446744073709551615.</p>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> import time
>>> from pymilvus import utility
>>> epoch_t = time.time()
>>> ts = utility.mkts_from_unixtime(epoch_t, milliseconds=1000.0)
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.mkts_from_datetime">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">mkts_from_datetime</code><span class="sig-paren">(</span><em class="sig-param">d_time</em>, <em class="sig-param">milliseconds=0.0</em>, <em class="sig-param">delta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.mkts_from_datetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a hybrid timestamp based on datetime, timedelta and incremental time internval.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d_time</strong> (<em>datetime.datetime.</em>) -- The known datetime used to generate a hybrid timestamp.</p></li>
<li><p><strong>milliseconds</strong> (<em>float</em>) -- Incremental time interval. The unit of time is milliseconds.</p></li>
<li><p><strong>delta</strong> (<em>datetime.timedelta</em>) -- A duration expressing the difference between two date, time, or datetime instances
to microsecond resolution.</p></li>
</ul>
</dd>
<dt class="field-even">Return int</dt>
<dd class="field-even"><p>Hybrid timetamp is a non-negative interger range from 0 to 18446744073709551615.</p>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> import datetime
>>> from pymilvus import utility
>>> d = datetime.datetime.now()
>>> ts = utility.mkts_from_datetime(d, milliseconds=1000.0)
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.hybridts_to_unixtime">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">hybridts_to_unixtime</code><span class="sig-paren">(</span><em class="sig-param">hybridts</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.hybridts_to_unixtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a hybrid timestamp to UNIX Epoch time ignoring the logic part.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>hybridts</strong> (<em>int</em>) -- The known hybrid timestamp to convert to UNIX Epoch time. Non-negative interger range from 0 to 18446744073709551615.</p>
</dd>
<dt class="field-even">Return float</dt>
<dd class="field-even"><p>The Unix Epoch time is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT).</p>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> import time
>>> from pymilvus import utility
>>> epoch1 = time.time()
>>> ts = utility.mkts_from_unixtime(epoch1)
>>> epoch2 = utility.hybridts_to_unixtime(ts)
>>> assert epoch1 == epoch2
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.hybridts_to_datetime">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">hybridts_to_datetime</code><span class="sig-paren">(</span><em class="sig-param">hybridts</em>, <em class="sig-param">tz=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.hybridts_to_datetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a hybrid timestamp to the datetime according to timezone.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hybridts</strong> (<em>int</em>) -- The known hybrid timestamp to convert to datetime. Non-negative interger range from 0 to 18446744073709551615.</p></li>
<li><p><strong>tz</strong> (<em>datetime.timezone</em>) -- Timezone defined by a fixed offset from UTC. If argument tz is None or not specified, the
hybridts is converted to the platform’s local date and time.</p></li>
</ul>
</dd>
<dt class="field-even">Return datetime</dt>
<dd class="field-even"><p>The datetime object.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>Exception</strong> -- If parameter tz is not of type datetime.timezone.</p>
</dd>
<dt class="field-even">Example</dt>
<dd class="field-even"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> import time
>>> from pymilvus import utility
>>> epoch_t = time.time()
>>> ts = utility.mkts_from_unixtime(epoch_t)
>>> d = utility.hybridts_to_datetime(ts)
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.create_alias">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">create_alias</code><span class="sig-paren">(</span><em class="sig-param">collection_name: str</em>, <em class="sig-param">alias: str</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.create_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify alias for a collection.
Alias cannot be duplicated, you can't assign the same alias to different collections.
But you can specify multiple aliases for a collection, for example:</p>
<blockquote>
<div><dl class="simple">
<dt>before create_alias(&quot;collection_1&quot;, &quot;bob&quot;):</dt><dd><p>aliases of collection_1 are [&quot;tom&quot;]</p>
</dd>
<dt>after create_alias(&quot;collection_1&quot;, &quot;bob&quot;):</dt><dd><p>aliases of collection_1 are [&quot;tom&quot;, &quot;bob&quot;]</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alias</strong> (<em>str.</em>) -- The alias of the collection.</p></li>
<li><p><strong>timeout</strong> (<em>float</em>) -- An optional duration of time in seconds to allow for the RPC. When timeout
is set to None, client waits until server response or error occur</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>CollectionNotExistException</strong> -- If the collection does not exist.</p></li>
<li><p><strong>BaseException</strong> -- If the alias failed to create.</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType, utility
>>> connections.connect()
>>> schema = CollectionSchema([
...     FieldSchema("film_id", DataType.INT64, is_primary=True),
...     FieldSchema("films", dtype=DataType.FLOAT_VECTOR, dim=2)
... ])
>>> collection = Collection("test_collection_create_alias", schema)
>>> utility.create_alias(collection.name, "alias")
Status(code=0, message='')
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.alter_alias">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">alter_alias</code><span class="sig-paren">(</span><em class="sig-param">collection_name: str</em>, <em class="sig-param">alias: str</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.alter_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the alias of a collection to another collection.
Raise error if the alias doesn't exist.
Alias cannot be duplicated, you can't assign same alias to different collections.
This api can change alias owner collection, for example:</p>
<blockquote>
<div><dl class="simple">
<dt>before alter_alias(&quot;collection_2&quot;, &quot;bob&quot;):</dt><dd><p>collection_1's aliases = [&quot;bob&quot;]
collection_2's aliases = []</p>
</dd>
<dt>after alter_alias(&quot;collection_2&quot;, &quot;bob&quot;):</dt><dd><p>collection_1's aliases = []
collection_2's aliases = [&quot;bob&quot;]</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>collection_name</strong> (<em>str.</em>) -- The collection name to witch this alias is goting to alter.</p></li>
<li><p><strong>alias</strong> (<em>str</em>) -- The alias of the collection.</p></li>
<li><p><strong>timeout</strong> (<em>float</em>) -- An optional duration of time in seconds to allow for the RPC. When timeout
is set to None, client waits until server response or error occur</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>CollectionNotExistException</strong> -- If the collection does not exist.</p></li>
<li><p><strong>BaseException</strong> -- If the alias failed to alter.</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType, utility
>>> connections.connect()
>>> schema = CollectionSchema([
...     FieldSchema("film_id", DataType.INT64, is_primary=True),
...     FieldSchema("films", dtype=DataType.FLOAT_VECTOR, dim=2)
... ])
>>> collection = Collection("test_collection_alter_alias", schema)
>>> utility.alter_alias(collection.name, "alias")
if the alias exists, return Status(code=0, message='')
otherwise return Status(code=1, message='alias does not exist')
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pymilvus.utility.drop_alias">
<code class="sig-prename descclassname">pymilvus.utility.</code><code class="sig-name descname">drop_alias</code><span class="sig-paren">(</span><em class="sig-param">alias: str</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">using='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#pymilvus.utility.drop_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the alias.
No need to provide collection name because an alias can only be assigned to one collection
and the server knows which collection it belongs.
For example:</p>
<blockquote>
<div><dl class="simple">
<dt>before drop_alias(&quot;bob&quot;):</dt><dd><p>aliases of collection_1 are [&quot;tom&quot;, &quot;bob&quot;]</p>
</dd>
<dt>after drop_alias(&quot;bob&quot;):</dt><dd><p>aliases of collection_1 are = [&quot;tom&quot;]</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alias</strong> (<em>str</em>) -- The alias to drop.</p></li>
<li><p><strong>timeout</strong> (<em>float</em>) -- An optional duration of time in seconds to allow for the RPC. When timeout
is set to None, client waits until server response or error occur</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>CollectionNotExistException</strong> -- If the collection does not exist.</p></li>
<li><p><strong>BaseException</strong> -- If the alias doesn't exist.</p></li>
</ul>
</dd>
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><code>>>> from pymilvus import connections, Collection, FieldSchema, CollectionSchema, DataType, utility
>>> connections.connect()
>>> schema = CollectionSchema([
...     FieldSchema("film_id", DataType.INT64, is_primary=True),
...     FieldSchema("films", dtype=DataType.FLOAT_VECTOR, dim=2)
... ])
>>> collection = Collection("test_collection_drop_alias", schema)
>>> utility.create_alias(collection.name, "alias")
>>> utility.drop_alias("alias")
Status(code=0, message='')
</code></pre></div>
</div>
</dd>
</dl>
</dd></dl>

</div>
